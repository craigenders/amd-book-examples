n <- 1000
id <- matrix(1:n) %x% matrix(1, nrow = nrow(lambda))
id
latents <-  matrix(rnorm(n * ncol(phi)), n) %*% chol(phi) %x% matrix(1, nrow = nrow(lambda))
latents
residuals <- matrix(rnorm(n * nrow(lambda))) %*% chol(vare)
timescores <- matrix(1, nrow = n) %x% lambda
timescores
y1 <- (timescores %*% kappa) + latents[,1] + (timescores[,2] * latents[,2]) + residuals
y <- (timescores %*% kappa) + latents[,1] + (timescores[,2] * latents[,2]) + residuals
growthdata <- cbind(id, timescores[,2], y)
head(growthdata)
names(growthdata) <- c("id","time","y")
library(nlme)
growth <- lme(fixed = y ~ time, random = ~ time|id, data = growthdata)
growthdata <- as.data.frame(cbind(id, timescores[,2], y))
growthdata <- as.data.frame(cbind(id, timescores[,2], y))
names(growthdata) <- c("id","time","y")
growth <- lme(fixed = y ~ time, random = ~ time|id, data = growthdata)
summary(growth)
n <- 100000
id <- matrix(1:n) %x% matrix(1, nrow = nrow(lambda))
latents <-  matrix(rnorm(n * ncol(phi)), n) %*% chol(phi) %x% matrix(1, nrow = nrow(lambda))
residuals <- matrix(rnorm(n * nrow(lambda))) %*% chol(vare)
timescores <- matrix(1, nrow = n) %x% lambda
y <- (timescores %*% kappa) + latents[,1] + (timescores[,2] * latents[,2]) + residuals
growthdata <- as.data.frame(cbind(id, timescores[,2], y))
names(growthdata) <- c("id","time","y")
growth <- lme(fixed = y ~ time, random = ~ time|id, data = growthdata)
summary(growth)
setwd("/users/craig/desktop/")
set.seed(90291)
# parameter values
lambda <- matrix(c(
1, 1, 1, 1, 1, 1,
0, 1, 2, 3, 4, 5
), nrow = 6, ncol = 2)
timesd <- .25
kappa <- matrix(c(12, -1))
phi <- t(matrix(c(
.25, 0,
0, .1
), nrow = 2, ncol = 2))
vare <- .4
# generate data (stacked, time fixed)
n <- 10000
id <- matrix(1:n) %x% matrix(1, nrow = nrow(lambda))
latents <-  matrix(rnorm(n * ncol(phi)), n) %*% chol(phi) %x% matrix(1, nrow = nrow(lambda))
residuals <- matrix(rnorm(n * nrow(lambda))) %*% chol(vare)
timescores <- matrix(1, nrow = n) %x% lambda
y <- (timescores %*% kappa) + latents[,1] + (timescores[,2] * latents[,2]) + residuals
growthdata <- as.data.frame(cbind(id, timescores[,2], y))
names(growthdata) <- c("id","time","y")
library(nlme)
growth <- lme(fixed = y ~ time, random = ~ time|id, data = growthdata)
summary(growth)
onedummy <- matrix(c(0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1), ncol = nrow(lambda)-1)
onedummy
dummies <- matrix(1, nrow = n) %x% onedummy
dummies
missX <- cbind(1, dummies, latents[,2])
head(miss)
head(missX)
iceptdiff <- micept - micept[1]
micept <- c(-3, -2.26, -2, -1.75, -1.5, -1.25)
iceptdiff <- micept - micept[1]
gammas <- c(micept[1],iceptdiff[2:6])
gammas
ppz <- missX %*% gammas
missX
ppz <- missX %*% t(gammas)
dim(missX)
dim(gammas)
length(gammas)
gammas
gammas <- c(micept[1],iceptdiff[2:6], mslope)
mslope <- 2.05
gammas <- c(micept[1],iceptdiff[2:6], mslope)
gammas
ppz <- missX %*% t(gammas)
ppz <- missX %*% gammas
head(ppz)
pnorm(ppz)
options(scipen = 999)
pnorm(ppz)
pp <- pnorm(ppz)
mean(pp)
# means at each assessment
psych::describeBy(pp, group = list(growthdata$time), mat = T, digits = 2)
ind <- rbinom(n, 1, prob)
ind <- rbinom(n, 1, pp)
head(cbind(pp,ind), 100)
mean(ind)
psych::describeBy(ind, group = list(growthdata$time), mat = T, digits = 2)
length(ind)
n
# means at each assessment
psych::describeBy(pp, group = list(growthdata$time), mat = T, digits = 2)
psych::describeBy(ind, group = list(growthdata$time), mat = T, digits = 2)
length(pp)
ind <- rbinom(n*6, 1, pp)
# means at each assessment
psych::describeBy(pp, group = list(growthdata$time), mat = T, digits = 2)
psych::describeBy(ind, group = list(growthdata$time), mat = T, digits = 2)
head(cbind(pp,ind), 100)
for(i in 1:n){
for(t in 1:6){
rowindex <- (i - 1) * 6 + t
print(rowindex)
}
}
for(i in 1:2){
for(t in 1:6){
rowindex <- (i - 1) * 6 + t
print(rowindex)
}
}
onedummy <- matrix(c(0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1), ncol = nrow(lambda)-1)
dummies <- matrix(1, nrow = n) %x% onedummy
missX <- cbind(1, dummies, latents[,2])
mslope <- 2.05
micept <- c(-5, -2.26, -2, -1.75, -1.5, -1.25)
iceptdiff <- micept - micept[1]
gammas <- c(micept[1],iceptdiff[2:6], mslope)
ppz <- missX %*% gammas
pp <- pnorm(ppz)
ind <- rbinom(n*6, 1, pp)
head(cbind(pp,ind), 100)
mean(pp)
mean(ind)
psych::describeBy(pp, group = list(growthdata$time), mat = T, digits = 2)
psych::describeBy(ind, group = list(growthdata$time), mat = T, digits = 2)
iceptdiff
onedummy <- matrix(c(0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1), ncol = nrow(lambda)-1)
dummies <- matrix(1, nrow = n) %x% onedummy
missX <- cbind(1, dummies, latents[,2])
mslope <- 2.05
micept <- c(-6, -2.26, -2, -1.75, -1.5, -1.25)
iceptdiff <- micept - micept[1]
gammas <- c(micept[1],iceptdiff[2:6], mslope)
ppz <- missX %*% gammas
pp <- pnorm(ppz)
ind <- rbinom(n*6, 1, pp)
# means at each assessment
head(cbind(pp,ind), 100)
mean(pp)
mean(ind)
psych::describeBy(pp, group = list(growthdata$time), mat = T, digits = 2)
psych::describeBy(ind, group = list(growthdata$time), mat = T, digits = 2)
dropout <- rep(0,length(ind))
length(dropout)
dropout <- rep(0,length(ind))
for(i in 1:n){
dindicator <- 0
for(t in 1:6){
rowindex <- (i - 1) * 6 + t
if(dindicator == 0 & ind[rowindex] == 1){
dropout[rowindex] <- 1
dindicator <- 1
}
if(dindicator == 1){dropout[rowindex] <- 999}
}
}
head(cbind(ind,dropout), 100)
timescores
head(cbind(timescores,ind,dropout), 100)
head(cbind(id,timescores,ind,dropout), 100)
dropout <- rep(0,length(ind))
for(i in 1:n){
dindicator <- 0
for(t in 1:6){
rowindex <- (i - 1) * 6 + t
if(dindicator == 1){dropout[rowindex] <- 999}
if(dindicator == 0 & ind[rowindex] == 1){
dropout[rowindex] <- 1
dindicator <- 1
}
}
}
head(cbind(id,timescores,ind,dropout), 100)
dropout <- rep(0,length(ind))
ymiss <- y
for(i in 1:n){
dindicator <- 0
for(t in 1:6){
rowindex <- (i - 1) * 6 + t
if(dindicator == 1){
dropout[rowindex] <- 999
ymiss[rowindex] <- 999}
if(dindicator == 0 & ind[rowindex] == 1){
dropout[rowindex] <- 1
ymiss[rowindex] <- 999
dindicator <- 1
}
}
}
head(cbind(id,timescores,y,ymiss,ind,dropout), 100)
timescores
dataout <- cbind(id, timescores[,2], ymiss, dropout)
write.table(dataout, "~/desktop/data16.dat")
write.table(dataout, "~/desktop/data16.dat", row.names = F, col.names = F)
dataout <- cbind(id, timescores[,2], round(ymiss,3), dropout)
write.table(dataout, "~/desktop/data16.dat", row.names = F, col.names = F)
setwd("/users/craig/desktop/")
set.seed(90291)
options(scipen = 999)
# parameter values
lambda <- matrix(c(
1, 1, 1, 1, 1, 1,
0, 1, 2, 3, 4, 5
), nrow = 6, ncol = 2)
timesd <- .25
kappa <- matrix(c(12, -1))
phi <- t(matrix(c(
.25, 0,
0, .1
), nrow = 2, ncol = 2))
vare <- .4
# generate data (stacked, time fixed)
n <- 1000
id <- matrix(1:n) %x% matrix(1, nrow = nrow(lambda))
latents <-  matrix(rnorm(n * ncol(phi)), n) %*% chol(phi) %x% matrix(1, nrow = nrow(lambda))
residuals <- matrix(rnorm(n * nrow(lambda))) %*% chol(vare)
timescores <- matrix(1, nrow = n) %x% lambda
y <- (timescores %*% kappa) + latents[,1] + (timescores[,2] * latents[,2]) + residuals
growthdata <- as.data.frame(cbind(id, timescores[,2], y))
names(growthdata) <- c("id","time","y")
library(nlme)
growth <- lme(fixed = y ~ time, random = ~ time|id, data = growthdata)
summary(growth)
onedummy <- matrix(c(0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1), ncol = nrow(lambda)-1)
dummies <- matrix(1, nrow = n) %x% onedummy
missX <- cbind(1, dummies, latents[,2])
mslope <- 2.05
micept <- c(-6, -2.26, -2, -1.75, -1.5, -1.25)
iceptdiff <- micept - micept[1]
gammas <- c(micept[1],iceptdiff[2:6], mslope)
ppz <- missX %*% gammas
pp <- pnorm(ppz)
ind <- rbinom(n*6, 1, pp)
# means at each assessment
head(cbind(pp,ind), 100)
mean(pp)
mean(ind)
psych::describeBy(pp, group = list(growthdata$time), mat = T, digits = 2)
psych::describeBy(ind, group = list(growthdata$time), mat = T, digits = 2)
dropout <- rep(0,length(ind))
ymiss <- y
for(i in 1:n){
dindicator <- 0
for(t in 1:6){
rowindex <- (i - 1) * 6 + t
if(dindicator == 1){
dropout[rowindex] <- 999
ymiss[rowindex] <- 999}
if(dindicator == 0 & ind[rowindex] == 1){
dropout[rowindex] <- 1
ymiss[rowindex] <- 999
dindicator <- 1
}
}
}
head(cbind(id,timescores,y,ymiss,ind,dropout), 100)
dataout <- cbind(id, timescores[,2], round(ymiss,3), dropout)
write.table(dataout, "~/desktop/data16.dat", row.names = F, col.names = F)
psych::describeBy(pp, group = list(growthdata$time), mat = T, digits = 2)
psych::describeBy(ind, group = list(growthdata$time), mat = T, digits = 2)
# example 7.3: joint model imputation
# requires fdir, jomo, and mitml packages
# set working directory
fdir::set()
# read data from working directory
dat <- read.table("math.dat", na.strings = "999")
names(dat) <- c("id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# define binary variable as factor
dat$frlunch <- factor(data$frlunch, levels = c(0,1))
# select variables for imputation
vars2impute <- c("frlunch", "stanread","mathpre", "mathpost")
# joint model imputation with jomo
imps <- jomo(dat[vars2impute], nburn = 1000, nbetween = 1000, nimp = 100)
# joint model imputation with jomo
imps <- jomo::jomo(dat[vars2impute], nburn = 1000, nbetween = 1000, nimp = 100)
View(imps)
# compute change score and save data
imps$change <- imps$mathpost - imps$mathpre
save(imps, file = "jomo.imps.R")
implist <- as.mitml.list(split(imps, imps$Imputation))
analysis <- with(implist, lm(change ~ 1))
# analysis and pooling
implist <- mitml::as.mitml.list(split(imps, imps$Imputation))
analysis <- with(implist, lm(change ~ 1))
# barnard & rubin degrees of freedom
estimates <- mitml::testEstimates(analysis, var.comp = T, df.com = 249)
# barnard & rubin degrees of freedom
estimates <- mitml::testEstimates(analysis, extra.pars = T, df.com = 249)
estimates
confint(estimates, level = .95)
# example 7.3: plot joint model imputations
# requires the fdir package
# set working directory
fdir::set()
save(imps, file = "jomo.imps.Rdata")
# load jomo imputations
load("jomo.imps.RData")
# missing data indicator
original.dat <- imps[Imputation == 0,]
# missing data indicator
original.dat <- imps[imps$Imputation == 0,]
indicator[is.na(original.dat$mathpost)]
indicator <- [is.na(original.dat$mathpost)]
indicator <- is.na(original.dat$mathpost)
indicator
indicator <- rep(is.na(original.dat$mathpost), 101)
original.dat <- imps[imps$Imputation == 0,]
imps$indicator <- rep(is.na(original.dat$mathpost), 101)
summary(imps[indicator == F, "mathpost"])
summary(imps[indicator == T, "mathpost"])
# observed and imputed data summaries
summary(imps[indicator == F & Imputation > 0, "mathpost"])
# observed and imputed data summaries
summary(imps[imps$indicator == F & imps$Imputation > 0, "mathpost"])
summary(imps[imps$indicator == T & imps$Imputation > 0, "mathpost"])
# add missing data indicator to imputed data
original.dat <- imps[imps$Imputation == 0,]
imps <- imps[imps$Imputation > 0,]
imps$indicator <- rep(is.na(original.dat$mathpost), 100)
hist(imps[imps$indicator == F, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 1), col= rgb(0.4,0.4,0.4,0.4), xlim = xrange, xlab = "Math Posttest Scores", ylab = NA, axes = T, main = "Observed vs. Imputed Data")
# plot observed vs. imputed data
xrange <- c(15,95)
hist(imps[imps$indicator == F, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 1), col= rgb(0.4,0.4,0.4,0.4), xlim = xrange, xlab = "Math Posttest Scores", ylab = NA, axes = T, main = "Observed vs. Imputed Data")
hist(impdat[imps$indicator == T, "bodmathpostydis"], breaks = seq(from = xrange[1], to = xrange[2], by = 1), col = "red", add = T, xlab = NA, ylab = NA, axes = F)
hist(imps[imps$indicator == T, "bodmathpostydis"], breaks = seq(from = xrange[1], to = xrange[2], by = 1), col = "red", add = T, xlab = NA, ylab = NA, axes = F)
hist(imps[imps$indicator == T, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 1), col = "red", add = T, xlab = NA, ylab = NA, axes = F)
xrange <- c(10,100)
hist(imps[imps$indicator == F, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 2), col= rgb(0.4,0.4,0.4,0.4), xlim = xrange, xlab = "Math Posttest Scores", ylab = NA, axes = T, main = "Observed vs. Imputed Data")
hist(imps[imps$indicator == T, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 2), col = "red", add = T, xlab = NA, ylab = NA, axes = F)
# example 7.3: joint model imputation
# requires fdir and mitml packages
# set working directory
fdir::set()
# load data
load("jomo.imps.Rdata")
# analysis and pooling
implist <- mitml::as.mitml.list(split(imps, imps$Imputation))
analysis <- with(implist, lm(change ~ 1))
# barnard & rubin degrees of freedom
estimates <- mitml::testEstimates(analysis, extra.pars = T, df.com = 249)
estimates
confint(estimates, level = .95)
# example 7.4: fully conditional specification multiple imputation
# requires fdir and mitml packages
# set working directory
fdir::set()
# read data from working directory
imps <- read.table("imps.dat", na.strings = "999")
names(dat) <- c("Imputation", "id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# read data from working directory
imps <- read.table("imps.dat", na.strings = "999")
# read data from working directory
imps <- read.table("imps.dat", na.strings = "999")
names(dat) <- c("Imputation", "id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
names(imps) <- c("Imputation", "id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
implist <- mitml::as.mitml.list(split(imps, imps$Imputation))
analysis <- with(implist, lm(change ~ 1))
# example 7.4: fully conditional specification multiple imputation
# requires fdir and mitml packages
# set working directory
fdir::set()
# read data from working directory
imps <- read.table("imps.dat", na.strings = "999")
names(imps) <- c("Imputation", "id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# compute change score from imputed data
imps$change <- imps$mathpost - imps$mathpre
implist <- mitml::as.mitml.list(split(imps, imps$Imputation))
analysis <- with(implist, lm(change ~ 1))
estimates <- mitml::testEstimates(analysis, extra.pars = T, df.com = 249)
estimates
confint(estimates, level = .95)
# example 7.4: fully conditional specification multiple imputation
# requires fdir and mitml packages
# set working directory
fdir::set()
# read data from working directory
imps <- read.table("imps.dat", na.strings = "999")
names(imps) <- c("Imputation", "id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# compute change score from imputed data
imps$change <- imps$mathpost - imps$mathpre
# analysis and pooling
implist <- mitml::as.mitml.list(split(imps, imps$Imputation))
analysis <- with(implist, lm(change ~ 1))
# barnard & rubin degrees of freedom
estimates <- mitml::testEstimates(analysis, extra.pars = T, df.com = 249)
estimates
confint(estimates, level = .95)
# example 7.3: plot joint model imputations
# requires the fdir package
# set working directory
fdir::set()
# read original data from working directory
original.dat <- read.table("math.dat", na.strings = "999")
names(original.dat) <- c("id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# read imputed data from working directory
imps <- read.table("imps.dat")
names(imps) <- c("Imputation", "id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# example 7.4: plot fully conditional specification imputations
# requires the fdir package
# set working directory
fdir::set()
# read original data from working directory
original.dat <- read.table("math.dat", na.strings = "999")
names(original.dat) <- c("id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# read imputed data from working directory
imps <- read.table("imps.dat")
names(imps) <- c("Imputation", "id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# add missing data indicator to imputed data
original.dat <- imps[imps$Imputation == 0,]
imps <- imps[imps$Imputation > 0,]
imps$indicator <- rep(is.na(original.dat$mathpost), 100)
# add missing data indicator to imputed data
imps$indicator <- rep(is.na(original.dat$mathpost), 100)
# example 7.4: plot fully conditional specification imputations
# requires the fdir package
# set working directory
fdir::set()
# read original data from working directory
original.dat <- read.table("math.dat", na.strings = "999")
names(original.dat) <- c("id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# read imputed data from working directory
imps <- read.table("imps.dat")
names(imps) <- c("Imputation", "id", "male", "frlunch", "achievegrp", "stanread", "efficacy", "anxiety", "mathpre", "mathpost")
# add missing data indicator to imputed data
imps$indicator <- rep(is.na(original.dat$mathpost), 100)
# observed and imputed data summaries
summary(imps[imps$indicator == F, "mathpost"])
summary(imps[imps$indicator == T, "mathpost"])
xrange <- c(10,100)
hist(imps[imps$indicator == F, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 2), col= rgb(0.4,0.4,0.4,0.4), xlim = xrange, xlab = "Math Posttest Scores", ylab = NA, axes = T, main = "Observed vs. Imputed Data")
hist(imps[imps$indicator == T, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 2), col = "red", add = T, xlab = NA, ylab = NA, axes = F)
xrange <- c(10,100)
hist(imps[imps$indicator == F, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 2), col= rgb(0.4,0.4,0.4,0.4), xlim = xrange, xlab = "Math Posttest Scores", ylab = NA, axes = T, main = "Observed vs. Imputed Data")
hist(imps[imps$indicator == T, "mathpost"], breaks = seq(from = xrange[1], to = xrange[2], by = 2), col = "red", add = T, xlab = NA, ylab = NA, axes = F)
# read imputed data from working directory
dat <- read.table("imps.dat")
names(dat) <- c("Imputation", "id", "txgrp", "male", "age", "edugroup", "workhrs", "exercise", "paingrps",
"pain", "anxiety", "stress", "control", "depress", "interfere", "disability",
paste0("dep", seq(1:7)), paste0("int", seq(1:6)), paste0("dis", seq(1:6)))
# set working directory
fdir::set()
# read imputed data from working directory
dat <- read.table("imps.dat")
names(dat) <- c("Imputation", "id", "txgrp", "male", "age", "edugroup", "workhrs", "exercise", "paingrps",
"pain", "anxiety", "stress", "control", "depress", "interfere", "disability",
paste0("dep", seq(1:7)), paste0("int", seq(1:6)), paste0("dis", seq(1:6)))
# center lower-order variable and compute product
imps$depress.cgm <- imps$depress - mean(imps$depress)
imps$depress.by.male <- imps$depress.cgm * imps$male
imps <- read.table("imps.dat")
names(imps) <- c("Imputation", "id", "txgrp", "male", "age", "edugroup", "workhrs", "exercise", "paingrps",
"pain", "anxiety", "stress", "control", "depress", "interfere", "disability",
paste0("dep", seq(1:7)), paste0("int", seq(1:6)), paste0("dis", seq(1:6)))
# center lower-order variable and compute product
imps$depress.cgm <- imps$depress - mean(imps$depress)
imps$depress.by.male <- imps$depress.cgm * imps$male
implist <- mitml::as.mitml.list(split(imps, imps$Imputation))
analysis <- with(implist, lm(disability ~ depress.cgm + male + depress.by.male + pain))
# significance tests with barnard & rubin degrees of freedom
mitml::testEstimates(analysis, extra.pars = T, df.com = 270)
# test conditional effects
slope.male <- c("depress.cgm + depress.by.male*1")
mitml::testConstraints(analysis, constraints = slope.male, df.com = 270)
slope.female <- c("depress.cgm + depress.by.male*0")
mitml::testConstraints(analysis, constraints = slope.female, df.com = 270)
nullmodel <- with(implist, lm(disability ~ 1))
# wald test that all slopes = 0
mitml::testModels(analysis, nullmodel, df.com = 270, method = "D1")
# likelihood ratio test that all slopes = 0
mitml::testModels(analysis, nullmodel, df.com = 270, method = "D3")
# likelihood ratio test that all slopes = 0
mitml::testModels(analysis, nullmodel, method = "D3")
options(scipen = 999)
# load packages
library(mitml)
library(lme4)
library(fdir)
# example 9.2: analyze model-based imputations from blimp
# requires fdir, lme4, and mitml packages
# set working directory
fdir::set()
# read data from working directory
imps <- read.table(paste0(getwd(), "/imps/longimps.dat"))
names(imps) <- c("Imputation","id","male","drug","severity","week","dropgrp","earlydrop","latedrop","dropout","sdropout")
imps$sqrtweek <- sqrt(imps$week)
# analysis and pooling
implist <- as.mitml.list(split(imps, imps$Imputation))
model <- "severity ~ sqrtweek + drug + sqrtweek*drug + (1 + sqrtweek | id)"
df <- c(435,1745,435,1745)
analysis <- with(implist, lmer(model, REML = T))
estimates <- testEstimates(analysis, extra.pars = T, df.com = df)
estimates
confint(estimates, level = .95)
# test conditional effects (simple slopes)
slope.male <- c("sqrtweek + sqrtweek:drug*1")
mitml::testConstraints(analysis, constraints = slope.male, df.com = 270)
# test conditional effects (simple slopes)
slope.tx <- c("sqrtweek + sqrtweek:drug*1")
mitml::testConstraints(analysis, constraints = slope.male, df.com = 1745)
slope.placebo <- c("sqrtweek + sqrtweek:drug*0")
mitml::testConstraints(analysis, constraints = slope.female, df.com = 1745)
slope.tx <- c("sqrtweek + sqrtweek:drug*1")
mitml::testConstraints(analysis, constraints = slope.tx, df.com = 1745)
slope.placebo <- c("sqrtweek + sqrtweek:drug*0")
mitml::testConstraints(analysis, constraints = slope.placebo, df.com = 1745)
