target.Rs <- cov2cor(sigma)
for(r in 1:nrow(sigma)){
for(c in 1:ncol(sigma)){
if(c != r){
cor.pointbi <- target.Rs[r,c] / sqrt(mu[1] * (1 - mu[1])) * dnorm(qnorm(mu[1]))
sigma.adj[r,c] <- sigma.adj[c,r] <- cor.pointbi * sqrt(sigma[r,r] * sigma[c,c])
}
}
}
sigma <- sigma.adj
mu
prob.miss <- .10
Rsq.miss <- .25
weights.scaled <- 1/sqrt(diag(sigma)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% sigma %*% weights.scaled))
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - slopes.miss %*% mu
icept.miss.start
mu
slopes.miss
# latent missingness variable
Rstar.Y <- cbind(1,dat) %*% gammas + matrix(rnorm(N * ncol(gammas), 0, 1), nrow = N)
# mean and variance of linear composite of predictors Z
scaling.ratios <- (1 / sqrt(sigma[nrow(sigma),ncol(sigma)])) * sqrt(diag(sigma))
beta.Z <- rep(1,length(scaling.ratios)) * scaling.ratios * importance.weights
var.Z <- t(beta.Z) %*% sigma %*% beta.Z
beta.Z <- rep(1,length(scaling.ratios)) * scaling.ratios * weights
var.Z <- t(beta.Z) %*% sigma %*% beta.Z
var.Z
sigma
beta.Z
N <- 1000000
popdat <- rmvnorm(N, mu, sigma)
10000*.000001
10000*.00001
10000*.0001
10000*.00001
10000*.00005
10000*.00001
5000*.00001
20000*.00001
seq(0, 20000*.00001, by = .00001)
seq(0, 20000*.00001, by = .00001) / 2
seq(0, 20000*.00001, by = .00001)
20000*.00001
seq(0, 20000*.00001, by = .00001)
icepts <- icept.miss.start - seq(0, 20000*.00001, by = .00001)
icepts <- icept.miss.start - c(seq(0, 20000*.00001, by = .00001))
icept.miss.start
icepts <- c(icept.miss.start) - seq(0, 20000*.00001, by = .00001)
icepts
length(icepts)
Rstar.Y.hat <- icept.miss.start + popdat %*% gammas
gammas
slopes.miss
popdat %*% slopes.miss
icept.miss.start + popdat %*% slopes.miss
icept.miss.start
icept.miss.start + popdat %*% slopes.miss
popdat %*% slopes.miss
icept.miss.start
as.numeric(icept.miss.start) + popdat %*% slopes.miss
mean(pred.prob <- pnorm(0, Rstar.Y.hat, 1))
sigma <- sigma.adj
mu <- mu
prob.miss <- .10
Rsq.miss <- .25
weights.scaled <- 1/sqrt(diag(sigma)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% sigma %*% weights.scaled))
N <- 100000
popdat <- rmvnorm(N, mu, sigma)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - slopes.miss %*% mu
icept.miss.start
Rstar.Y.hat <- as.numeric(icept.miss.start) + popdat %*% slopes.miss
Rstar.Y.hat
mu
pred.prob <- pnorm(0, Rstar.Y.hat, 1))
pred.prob <- pnorm(0, Rstar.Y.hat, 1)
pred.prob
ean(pred.prob)
mean(pred.prob)
icept.miss.start <- qnorm(prob.miss, 0  - slopes.miss %*% mu, 1, lower.tail = T)
icept.miss.start
0  - slopes.miss %*% mu
prob.miss
icept.miss.start <- qnorm(prob.miss, 0  - slopes.miss %*% mu, 1, lower.tail = T)
icept.miss.start
Rstar.Y.hat <- as.numeric(icept.miss.start) + popdat %*% slopes.miss
Rstar.Y.hat <- as.numeric(icept.miss.start) + popdat %*% slopes.miss
pred.prob <- pnorm(0, Rstar.Y.hat, 1)
mean(pred.prob)
qnorm(prob.miss, 0, 1, lower.tail = T)
mu * slopes.miss
mu %*% slopes.miss
mu
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu %*% slopes.miss
icept.miss.start
popdat %*% slopes.miss
icept.miss.start
summary(popdat %*% slopes.miss)
Rstar.Y.hat <- as.numeric(icept.miss.start) + popdat %*% slopes.miss
pred.prob <- pnorm(0, Rstar.Y.hat, 1, lower.tail = F)
mean(pred.prob)
N <- 100000
popdat <- rmvnorm(N, mu, sigma)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu %*% slopes.miss
stepsize <- .001
tol <- .001
inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start - inc) + popdat %*% slopes.miss
if(abs(prob.miss - mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))) <= tol){
icept.miss <- icept.miss.start - inc
break
}
}
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start - inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start - inc
break
}
}
stepsize <- .001
tol <- .001
inc <- 0
inc <- inc - stepsize
inc
icept.miss.start
icept.miss.start - inc
Rstar.Y.hat <- as.numeric(icept.miss.start - inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
mean.prob
prob.miss
print(mean.prob)
stepsize <- .001
tol <- .001
inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start - inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start - inc
break
}
}
stepsize <- .001
tol <- .001
inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start - inc
break
}
}
stepsize <- .001
tol <- .0001
inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start - inc
break
}
}
stepsize <- .001
tol <- .00001
inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start - inc
break
}
}
stepsize <- .0001
tol <- .00001
inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start - inc
break
}
}
stepsize <- .001
tol <- .0001
inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start - inc
break
}
}
stepsize <- .001
tol <- .0001
inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
icept.miss
icept.miss.start
missingness.model.function <- function(Rsq.miss, prob.miss, weights, mu, sigma){
# solve for slopes
weights.scaled <- 1/sqrt(diag(sigma)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% sigma %*% weights.scaled))
# iteratively solve for intercept
N <- 100000
popdat <- rmvnorm(N, mu, sigma)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu %*% slopes.miss
stepsize <- .001; tol <- .0001; inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
return(c(icept.miss,slopes.miss))
}
weights <- c(.5,.5,0,0,0,0)
t3.coeff <- missingness.model.function(Rsq.miss = .15, prob.miss = .10, weights = weights, mu = mu, sigma = sigma.adj)
t4.coeff <- missingness.model.function(Rsq.miss = .15, prob.miss = .20, weights = weights, mu = mu, sigma = sigma.adj)
t5.coeff <- missingness.model.function(Rsq.miss = .15, prob.miss = .40, weights = weights, mu = mu, sigma = sigma.adj)
t3.coeff <- missingness.model.function(Rsq.miss = .15, prob.miss = .10, weights = weights, mu = mu, sigma = sigma.adj)
t3.coeff <- missingness.model.function(Rsq.miss = .15, prob.miss = .10, weights = weights, mu = mu, sigma = sigma.adj)
missingness.model.function <- function(Rsq.miss, prob.miss, weights, mu, sigma){
# solve for slopes
weights.scaled <- 1/sqrt(diag(sigma)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% sigma %*% weights.scaled))
# iteratively solve for intercept
N <- 100000
popdat <- rmvnorm(N, mu, sigma)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu %*% slopes.miss
stepsize <- .001; tol <- .001; inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
return(c(icept.miss,slopes.miss))
}
# specify
weights <- c(.5,.5,0,0,0,0)
t3.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .10, weights = weights, mu = mu, sigma = sigma.adj)
t4.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .20, weights = weights, mu = mu, sigma = sigma.adj)
t5.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .40, weights = weights, mu = mu, sigma = sigma.adj)
t5.coeff
N <- 100000
popdat <- rmvnorm(N, mu, sigma)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu %*% slopes.miss
stepsize <- .001; tol <- .001; inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
return(c(icept.miss,slopes.miss))
}
missingness.model.function <- function(Rsq.miss, prob.miss, weights, mu, sigma){
# solve for slopes
weights.scaled <- 1/sqrt(diag(sigma)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% sigma %*% weights.scaled))
# iteratively solve for intercept
N <- 100000
popdat <- rmvnorm(N, mu, sigma)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu %*% slopes.miss
stepsize <- .001; tol <- .001; inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
return(c(icept.miss,slopes.miss))
}
# specify
weights <- c(.5,.5,0,0,0,0)
t3.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .10, weights = weights, mu = mu, sigma = sigma.adj)
t4.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .20, weights = weights, mu = mu, sigma = sigma.adj)
t5.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .40, weights = weights, mu = mu, sigma = sigma.adj)
missingness.model.function <- function(Rsq.miss, prob.miss, weights, mu, sigma){
# solve for slopes
weights.scaled <- 1/sqrt(diag(sigma)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% sigma %*% weights.scaled))
# iteratively solve for intercept
N <- 100000
popdat <- rmvnorm(N, mu, sigma)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu %*% slopes.miss
stepsize <- .0001; tol <- .0001; inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
return(c(icept.miss,slopes.miss))
}
t3.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .10, weights = weights, mu = mu, sigma = sigma.adj)
t4.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .20, weights = weights, mu = mu, sigma = sigma.adj)
t5.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .40, weights = weights, mu = mu, sigma = sigma.adj)
gammas <- cbind(t3.coeff,t4.coeff,t5.coeff)
logistic <- gammas * 1.7
N <- 100000
dat <- rmvnorm(N, mu, sigma.adj)
dat[dat[,1] >= mu[1],1] <- 1
dat[dat[,1] < mu[1],1] <- 0
head(dat)
# latent missingness variable
Rstar.Y <- cbind(1,dat) %*% gammas + matrix(rnorm(N * ncol(gammas), 0, 1), nrow = N)
R.Y <- matrix(0, nrow = N, ncol = 3)
R.Y[Rstar.Y > 0] <- 1
colMeans(R.Y)
Rstar.Y
gammas
logistic <- gammas * 1.7
logistic
library(mvtnorm)
missingness.model.function <- function(Rsq.miss, prob.miss, weights, mu, sigma){
# solve for slopes
weights.scaled <- 1/sqrt(diag(sigma)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% sigma %*% weights.scaled))
# iteratively solve for intercept
N <- 100000
popdat <- rmvnorm(N, mu, sigma)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu %*% slopes.miss
stepsize <- .0001; tol <- .0001; inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
return(c(icept.miss,slopes.miss))
}
# growth model parameters
# binary predictor
mu.x <- .5
var.x <- mu.x * (1 - mu.x)
# time scores
timescores <- c(0,1,2,3,4)
# regression of growth factors on binary x
gamma <- c(0,0.9212)
# growth factor intercepts
mu.factors <- c(50,0.70711)
# growth factor loading matrix
loadings <- matrix(c(rep(1, length(timescores)), timescores), ncol = 2)
# growth factor variances
sigma.factors <- matrix(c(49.15139,3.32552,3.32552,2.5), ncol = 2)
# within-person residual
sigma.residuals <- diag(length(timescores)) * 41
# model-predicted mean vector and covariance matrix
mu.repeated <- loadings %*% (mu.factors + gamma * mu.x)
mu <- c(mu.x,mu.repeated)
cov.repeated <- loadings %*% (var.x * gamma %*% t(gamma) + sigma.factors) %*% t(loadings) + sigma.residuals
cov.off.diag <- var.x * t(gamma) %*% t(loadings)
sigma <- rbind(cbind(var.x, cov.off.diag),cbind(t(cov.off.diag),cov.repeated))
# adjust covariances for binary variable
sigma.adj <- sigma
target.Rs <- cov2cor(sigma)
for(r in 1:nrow(sigma)){
for(c in 1:ncol(sigma)){
if(c != r){
cor.pointbi <- target.Rs[r,c] / sqrt(mu[1] * (1 - mu[1])) * dnorm(qnorm(mu[1]))
sigma.adj[r,c] <- sigma.adj[c,r] <- cor.pointbi * sqrt(sigma[r,r] * sigma[c,c])
}
}
}
# specify proportional missingness weights and solve for probit coefficients
weights <- c(.5,.5,0,0,0,0)
t3.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .10, weights = weights, mu = mu, sigma = sigma.adj)
t4.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .20, weights = weights, mu = mu, sigma = sigma.adj)
t5.coeff <- missingness.model.function(Rsq.miss = .25, prob.miss = .40, weights = weights, mu = mu, sigma = sigma.adj)
# missingness model parameters
missingness.regressions <- cbind(t3.coeff,t4.coeff,t5.coeff)
logistic.4.mplus <- gammas * 1.7
logistic.4.mplus
sigma <- matrix(.3, nrow = length(means), ncol = length(means)); diag(sigma) <- 1
# specify proportional missingness weights and solve for probit coefficients
means <- c(0,0,0,0,0)
sigma <- matrix(.3, nrow = length(means), ncol = length(means)); diag(sigma) <- 1
library(mvtnorm)
missingness.model.function <- function(Rsq.miss, prob.miss, weights, mu.all.all, cov.all){
# solve for slopes
weights.scaled <- 1/sqrt(diag(cov.all)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% cov.all %*% weights.scaled))
# iteratively solve for intercept
N <- 100000
popdat <- rmvnorm(N, mu.all, cov.all)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu.all %*% slopes.miss
stepsize <- .0001; tol <- .0001; inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
return(c(icept.miss,slopes.miss))
}
means <- c(0,0,0,0,0)
sigma <- matrix(.3, nrow = length(means), ncol = length(means)); diag(sigma) <- 1
weights <- c(.5,.5,0,0,0,0)
gammas <- missingness.model.function(Rsq.miss = .25,
prob.miss = .10,
weights = weights,
mu.all = means,
cov.all = sigma)
means <- c(0,0,0,0,0,0)
sigma <- matrix(.3, nrow = length(means), ncol = length(means)); diag(sigma) <- 1
weights <- c(.5,.5,0,0,0,0)
gammas <- missingness.model.function(Rsq.miss = .25,
prob.miss = .10,
weights = weights,
mu.all = means,
cov.all = sigma)
sigma
means
weights <- c(.5,.5,0,0,0,0)
gammas <- missingness.model.function(Rsq.miss = .25,
prob.miss = .10,
weights = weights,
mu.all = means,
cov.all = sigma)
library(mvtnorm)
missingness.model.function <- function(Rsq.miss, prob.miss, weights, mu.all, cov.all){
# solve for slopes
weights.scaled <- 1/sqrt(diag(cov.all)) * weights
slopes.miss <- weights.scaled * c(sqrt(((1 - (Rsq.miss / (Rsq.miss - 1))) * Rsq.miss) / t(weights.scaled) %*% cov.all %*% weights.scaled))
# iteratively solve for intercept
N <- 100000
popdat <- rmvnorm(N, mu.all, cov.all)
icept.miss.start <- qnorm(prob.miss, 0, 1, lower.tail = T) - mu.all %*% slopes.miss
stepsize <- .0001; tol <- .0001; inc <- 0
repeat{
inc <- inc - stepsize
Rstar.Y.hat <- as.numeric(icept.miss.start + inc) + popdat %*% slopes.miss
mean.prob <- mean(pnorm(0, Rstar.Y.hat, 1, lower.tail = F))
print(mean.prob)
if(abs(prob.miss - mean.prob ) <= tol){
icept.miss <- icept.miss.start + inc
break
}
}
return(c(icept.miss,slopes.miss))
}
# specify proportional missingness weights and solve for probit coefficients
means <- c(0,0,0,0,0,0)
sigma <- matrix(.3, nrow = length(means), ncol = length(means)); diag(sigma) <- 1
weights <- c(.5,.5,0,0,0,0)
gammas <- missingness.model.function(Rsq.miss = .25,
prob.miss = .10,
weights = weights,
mu.all = means,
cov.all = sigma)
gammas
